import { PackingRecord, PACKAGE_COLUMNS } from '../../types';
import { parseDisplayDate, formatDisplayDate } from '../../utils';

// This URL should be provided by the user after deployment
// For now, we'll check for an env var or default to empty to prompt them
const GOOGLE_SCRIPT_URL = import.meta.env.VITE_GOOGLE_SCRIPT_URL || '';

export const fetchPackingData = async (): Promise<PackingRecord[]> => {
  if (!GOOGLE_SCRIPT_URL) {
    console.warn('Google Script URL is not set.');
    return [];
  }

  try {
    const response = await fetch(GOOGLE_SCRIPT_URL);
    if (!response.ok) throw new Error('Network response was not ok');
    
    const json = await response.json();
    if (json.status !== 'success') throw new Error(json.message);

    // Map the array of arrays (A:Y) to PackingRecord objects
    // Col A is index 0. We start actual data fields from Col B (index 1)
    // Timestamp is index 0. Remark is index 24.
    
    return json.data.map((row: string[], index: number) => {
      const record: PackingRecord = {
        id: `row-${index}-${Date.now()}`,
        Timestamp: row[0],
        Date: parseDisplayDate(row[1]), // Convert DD/MM/YYYY to YYYY-MM-DD
        Shipment: row[2],
        Mode: row[3],
        Product: row[4],
        "SI QTY": Number(row[5]) || 0,
        QTY: Number(row[6]) || 0,
        Remark: row[24],
      };

      // Map dynamic package columns (Indices 7-23 match PACKAGE_COLUMNS 0-16)
      PACKAGE_COLUMNS.forEach((colName, colIndex) => {
        // row index = 7 + colIndex
        record[colName] = Number(row[7 + colIndex]) || 0;
      });

      return record;
    });
  } catch (error) {
    console.error('Error fetching data:', error);
    return [];
  }
};

export const submitPackingData = async (record: PackingRecord): Promise<boolean> => {
  if (!GOOGLE_SCRIPT_URL) {
    alert('Google Script URL not configured!');
    return false;
  }

  // Convert record back to array for sending
  // We only send B-Y (indices 1-24). Timestamp (A) is generated by server script.
  
  const values = [
    formatDisplayDate(record.Date), // Convert YYYY-MM-DD to DD/MM/YYYY
    record.Shipment,
    record.Mode,
    record.Product,
    record["SI QTY"],
    record.QTY
  ];
  
  // Package columns in order
  PACKAGE_COLUMNS.forEach(col => {
    values.push(record[col] as number);
  });
  
  // Add Remark (Y)
  values.push(record.Remark || '');

  try {
    // Send as POST
    // We use no-cors if simple POST, but for returning data we usually need CORS handling in script
    // But standard fetch with text/plain body often avoids preflight if configured right.
    // However, Apps Script Web Apps handle POST redirects which browser fetch follows.
    
    const payload = JSON.stringify({ values });
    
    const response = await fetch(`${GOOGLE_SCRIPT_URL}?action=add`, {
      method: 'POST',
      body: payload
    });

    const json = await response.json();
    return json.status === 'success';
  } catch (error) {
    console.error('Error submitting data:', error);
    // Fallback: If CORS opaque response issues occur (common with GAS), 
    // we might assume success if no network error thrown, but explicit JSON is better.
    return false;
  }
};
